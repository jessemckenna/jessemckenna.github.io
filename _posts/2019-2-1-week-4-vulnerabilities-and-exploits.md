---
layout: post
title: Week 4, vulnerabilities and exploits
date: 2019-2-1
---

Unlike previous weeks, which were focused on responding to exploits and malware, this week's lectures contained walkthroughs of two basic types of exploits: a buffer-length (i.e. stack-overflow) exploit, and a use-after-free exploit, both done on a purposely vulnerable browser plugin.
<!--more-->

#### Exploit basics
An exploit is control of a program in a way not intended by the programmer, gained by taking advantage of a vulnerability in some existing software. The vulnerability, or software bug, taken advantage of in an exploit is called the *vulnerability trigger*, and the action taken once exploited is called the *payload*. The payload depends heavily on the situation; it could be execution of some code, acquisition of direct control, or small modifications to memory that have some desired effect. Traditionally, payload code is called *shellcode* due to its commonly being used to run commands in the OS shell.

This week's labs focused on exploits done via *memory corruption*, which is the accessing of memory access in an invalid, unintended way, resulting in undefined behavior.

The most common categories of memory corruption exploits take advantage of:
* Lifetime control, ex. use after free
* Uninitialized memory
* Array index calculations
* Buffer length calculations, ex. stack overflow

#### Optional lab: stack-overflow exploit
This week's lab was a demonstration of how a buffer-length exploit is done. The lab involved a vulnerable ActiveX module called *FSExploitMe* that we investigated using WinDBG. I had a lot of trouble following along with this week's lab due to the presentation style - it was hard to understand which part of the lecture corresponded to which lab, there was often limited view of the screen, and the lecturer seemed to jump around a lot. Since I didn't complete the lab, I will describe my general takeaways rather than walking through step by step.

Debugging with WinDBG seems like a lot of fun! Some examples of WinDBG functionality as demonstrated in the lab include:
* Finding the address of a module:
WinDBG command *lmf m FSExploitMe* listed modules matching "FSExploitMe".
* Finding the location of the stack:
WinDBG command *!teb* displayed the stack's memory range, starting at *StackBase* and ending at *StackLimit*. From these two fields, it is also possible to calculate the size of the stack.
* Break execution by function name, memory address, etc.:
WinDBG command *bp* sets a breakpoint, and can be given various arguments at which to break.
* Find the starting address of the process heap:
WinDBG command *!peb* displays process-specific information (as opposed to *!teb*, which displays thread-specific information). This was important as Internet Explorer, the program being used to execute the shellcode, uses multiple threads.
* View upcoming assembly commands at a point in execution:
WinDBG command *u eip* displays the assembly commands next to execute. This was used in the lab to determine how much space was being created on the stack for local variables (as the command *sub esp, 14h* was found, wherein the stack pointer is decremented to create space for local variables).

#### Reflection
This week was interesting overall in spite of the slightly confusing lab. Even without following along, it was fun to watch the lecturer manipulate the program using the information gleaned from WinDBG. Having seen and heard about WinDBG but never used it before, I enjoyed getting a chance to try it out myself. It was also fun to dust off my MASM from last year!