---
layout: post
title: Final
date: 2019-3-13
---

This is my final project for CS373. The final is to complete 'hacking' challenges on a sandbox website designed to allow people to practice these techniques. As posting solutions to the challenges is against the site's ToS, I will take down this post after it has been graded.

<!--more-->
#### Invite code

**How I completed this challenge:**

I stepped through the function defined in *inviteapi.js* and saw in its return value an API call to function *makeInviteCode()* at URL */api/invite/how/to/generate*. I ran this POST request in a separate script, which returned encoded instructions on how to request an invite code: "In order to generate the invite code, make a POST request to /api/invite/generate". I modified my POST request's URL to */api/invite/generate*, and this returned another encoded string. I decoded it with the same encoding as was used in the instructions string (base64), which resulted in a working invite code.

**Thought process:**

This first step was really challenging for me as I really had no idea where to start.

My first thought was to poke around in Chrome Dev Tools to try and see if I could find some hint on what constitutes a valid invite code - for example, some kind of input validation built into the form submittal.

After digging through the site's frontend .js file, I felt a bit lost and decided I needed a more efficient way of finding what I was looking for. After all, I figured there was no way the actual challenges would consist of "read all the .js until you find something". I noticed that Dev Tools has a breakpoint feature and wondered if I could submit a wrong invite code and then somehow monitor the page to see what happens when it checks for invite code validity.

I set an Event Listener Breakpoint on Control > submit, i.e. told Dev Tools to break when a form is submitted. This resulted in a lot of freezing of Chrome in general, which I ultimately found out was caused by my extensions. Lesson learned: disable extensions before using Dev Tools!

This train of thought ended up being abruptly interrupted when I noticed an *inviteapi* script that I had missed before in the site's files.

It defined and called a function that receives as parameter a long string of symbols that resembled a regular expression, followed by two numbers and another string containing what looked like a list of function names.

Of most interest to me in this list of function names was *makeInviteCode*. I tried to call it directly from the Dev Tools console but got an error message, so I instead tried stepping through the function to see exactly what it did and hopefully get some hints on whether I could potentially call this function.

The return value of the function defined in *inviteapi* was a long string containing calls to functions *verifyInviteCode(code)* and *makeInviteCode()*. It seemed to me that this function was essentially a compact caller for the actual API. I copied the contents of the full POST request to *makeInviteCode()* that I found in the function's return value, which included a link to the API URL */api/invite/how/to/generate* from which a code could be returned.

I pasted this POST request into the console to see if I could print the result of the call to *makeInviteCode()*, but it printed *undefined*. I also tried pasting it into the invite code form field, hoping to make [the result of the function makeInviteCode()] my code input value, but this simple approach didn't have any effect. I also tried modifying the return value of the function-selection function directly in Dev Tools, but it didn't save my changes. At this point I was feeling pretty stupid, but oh well!

I felt that I was perhaps onto something with running the function in the console, but was unsure why I was getting a return value of *undefined*. I tried running the script in a snippet (a short temporary file provided by Dev Tools to run JS scripts) instead, but got the same result. I realized that since I was running this function outside the site itself, I needed to add the site URL before the relative URL contained in the arguments.

After I fixed that mistake, I got a return value - a 404 error! This was pretty exciting, because it meant at least I had the JS working. I tried tweaking the URL a little (I had made some assumptions about what the first portion of the URL would contain, and was unsure), and this time I got a successful response containing a code! Pretty exciting. I copy-pasted it into the input field, and to my surprise... it didn't work.

I noticed another field was returned, *enctype: "base64"*. Maybe I needed to decode it? I went ahead and did that, and instead of the code I was expecting, I got a string instead: "In order to generate the invite code, make a POST request to /api/invite/generate".

This was super disappointing! Did I just trigger the tutorial mode for slow people?? Actually, when I looked at the URL, I realized that I was making a request to *api/invite/how/to/generate* the whole time, so I don't know what I expected.

Once I made the POST request to the correct URL at *api/invite/generate*, I got a code! It also had a second field *format: "encoded"*. I went ahead and decoded it from base64 again (essentially guessing that it would be encoded the same way), and the result worked!

**Tools used:**

I only used Chrome Dev Tools for this challenge, including the snippet feature for running JS separately from the page.

#### Challenge 1: Deceitful Batman (10 points)

**How I completed this challenge:**

I researched how to decrypt an unknown cipher, and through this research found out that most two-character encryptions use *Baconian ciphers*. I split the ciphertext into five-character segments (as Baconian ciphers substitute five-digit segments for letters) and found that it split evenly, which further supported the idea that the cipher was Baconian. Based on this, I entered the string contained in the challenge file into an online Bacon cipher decoder. The tool successfully returned a string that explicitly told me the flag.

**Thought process:**

After I got access to the challenges themselves, I began by installing a Kali Linux VM to help me with the challenges, as Kali Linux offers VirtualBox VM images pre-installed with a wide variety of tools.

This challenge was under the *cryptography* section and contained a single text file containing a string of A's and N's. I decided to see if the Kali Linux VM I set up earlier had any cryptography-related tools that could be helpful to me.

I found one called *hashcat*, but it seemed to want to know what kind of hash was being used - I may have just been holding it wrong, but it didn't seem like what I was looking for. After doing more research, I found another built-in program called *hashid* that seemed like it could identify the hash type for me.

I ran *hashid* with the string contents from the file, and it gave me the output "[+] BigCrypt". So far, so good! At this point I really felt like installing the VM was worth the effort.

I went back to *hashcat* hoping to decrypt the string at this point, but unfortunately didn't find BigCrypt in its list of hash modes. I did a bit of searching online, and found a few pages that seemed to indicate that another program called *john* on Kali Linux supports BigCrypt decryption. Unfortunately, I couldn't get this other program to work either - it seemed to not have support for the BigCrypt format. I tried a few different related-seeming formats such as *des* and *crypt*, but came up with no result for any of them.

At this point I was feeling a little frustrated, especially as this was only a 10-point challenge. Perhaps I was overcomplicating it? I thought the tools would perhaps make the challenge trivial, but that seemed to not be the case. I decided to go back to square one and research the best way to identify an unknown encryption. I found an article on this topic that stated that most two-character encryptions are likely to use *Baconian ciphers*, wherein each letter is replaced with a sequence of five binary digits.

I returned to the encrypted text and broke it into five-digit segments; it split evenly that way, which seemed to be a good sign.

I went to an online "Bacon Cipher decoder" and pasted the string there, and got a result string that told me the flag! After I stopped overengineering my approach, I reached the solution surprisingly quickly.

**Tools used:**

Although I experimented with several tools, including *hashid*, *hashcat*, and *john* on a Kali Linux VM, I ultimately only needed online research (particularly the article on decrypting unknown ciphers at [Practical Cryptography](http://practicalcryptography.com/cryptanalysis/text-characterisation/identifying-unknown-ciphers/)), plus the Bacon cipher decoder at [dCode](https://www.dcode.fr/bacon-cipher).

#### Challenge 2: Sick Teacher (20 points)

**How I completed this challenge:**



**Thought process:**



**Tools used:**



#### Challenge 3: Weak RSA (20 points)

**How I completed this challenge:**



**Thought process:**



**Tools used:**



#### Reflection
